% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kin.R
\name{kin.free}
\alias{kin.free}
\title{Contour and midline tracking of free-moving ROIs over image sequences}
\usage{
kin.free(
  image.dir = NULL,
  frames = NULL,
  par = FALSE,
  cores.n = NULL,
  ant.per = 0.1,
  ant.pos = NULL,
  tips = 0.02,
  smooth.n = 1,
  red = NULL,
  ml.meth = "hull",
  ml.smooth = list("spline", 0.25),
  save = FALSE,
  out.qual = 1,
  out.dir = NULL,
  plot.pml = TRUE,
  flip = TRUE,
  ...
)
}
\arguments{
\item{image.dir}{character, directory containing images to analyze.}

\item{frames}{numeric, vector indicating which images to process. Must be >1. See Details.}

\item{par}{logical, should the frames be processed in parallel using \code{cores.n}.}

\item{cores.n}{numeric, the number of CPU cores to use if \code{par=TRUE}. If \code{cores.n=NULL} (the default), the total number of cores minus 1 are used.}

\item{ant.per}{numeric; anterior percentage of ROI that establishes the reference for the midline displacement.}

\item{ant.pos}{character, one of , NULL, "l","r","u",or "d" to specify the position of the anterior of the ROI. If not NULL, the default algorithm to find the anterior is overridden. See Details.}

\item{tips, }{numeric, the proportion the the midline data to use in calculation of the head and tail position.}

\item{smooth.n, }{numeric, the number of contour smoothing iterations. See Details.}

\item{red}{numeric, between 0-1 the proportion of contour coordinates to sample for midline estimates. Ignored if \code{ml.meth} is not 'del'. Will speed up midline estimations with Delauny triangulation. If 'NULL', the full contour retrieved from the ROI will be passed to \code{\link{free.ml.del}}. See Detail.}

\item{ml.meth}{character, the midline detection method. One of 'ang' for bisection using \code{\link{free.ml.ang}}, 'hull' for bisection using \code{\link{free.ml.hull}}, or 'del' for Delaunay triangulation using \code{\link{free.ml.del}}. See Details.}

\item{ml.smooth}{a list of length two with unnamed components including a character string specifying the midline smoothing method, either 'loess' or "spline", and a numeric value specifying the amount of smoothing. See Details.}

\item{save}{logical, value indicating if images should be outputted with midline and predicted midline based on the \code{ant.per} \code{lm} overlaying original or binary images.}

\item{out.qual, }{numeric, a value between 0-1 representing the quality of outputted images. Ignored if \code{save=FALSE}.}

\item{out.dir}{character, the directory to which outputted images should be saved.}

\item{plot.pml}{logical, value indicating if outputted images should include an overlay of the midline, head region and theoretical midline based on \code{ant.per}.}

\item{thr}{numeric or character ('otsu'); the threshold to determine binary image. See Details.}

\item{.}{. . , other arguments passed to \code{\link{find.roi}}}
}
\value{
A list with the following components:

\code{kin.dat} a data table consisting of frame-by-frame position parameters for the ROI
\itemize{
\item the frame number
\item 'x' and 'y': the position of the tail (rightmost or posteriormost)
\item 'head.x' and 'head.y': the x and y position of the head (leftmost or anteriormost)
\item 'amp': the amplitude of the tail (taken from 'wave.y' of \code{midline})
#' \item 'head.pval': p values of the \code{lm()} fit that describes the position of the head as determined by \code{ant.per} (green points in the outputted images)
\item 'roi': a character indicating ROI size ('a' being the largest)
\item 'edge': was the roi on the edge of the frame}

\code{midline} A data table containing, for each frame described by \code{frames}, the following: \itemize{
\item 'x' and 'y': x and y positions of the midline of the ROI
\item 'x.sm' and 'y.sm': the smoothed midline positions predicted by \code{ml.smooth}.
\item 'wave.y': orthogona distance of midline points from predicted midline (see below)
\item 'per.bl': the percentage of 'x.sm' along the body length calculated as the cumulative sum of distances between points
}

\code{cont} A data table containing x and y positions of the contours used to calculate the data in 'kin.dat'. Contains the following:
\itemize{
\item 'frame': the frame
\item 'x' and 'y': the x and y positions of the contours
}

\code{cont.sm} A data table containing x and y positions of the smooth contours. Contains the following:
\itemize{
\item 'frame': the frame
\item 'n': the position of the coordinate. n=1 and max(n) are adjacent at the head
\item 'x' and 'y': the x and y positions of the contours
}


#' \code{all.classes} A data table containing the following for all ROIs detected:
\itemize{
\item 'frame': the frame
\item 'roi': the name of each ROI found in a frame.
\item 'edge': indicating whether ROI was on the edge of the image field
\item 'size': size of the ROI in pixels^2
\item 'offset.x': ROI distance from horizontal center
\item 'offset.y': ROI distance from vertical center
\item 'offset': linear distance of ROI's centroid to image center
}

\code{mid.pred} the theoretical midline based on a linear model established by the anterior section of of the smoothed midline established by \code{ant.per}. Used to calculate \code{midline$wave.y} as the orthogonal distance between the line defined by 'x' and 'mid.pred' and each coordinate defined by '\code{midline$x.sm} and \code{midline$y.sm}. A data table that contains the following:
\itemize{
\item 'frame': the frame
\item 'x': x position of the predicted midline
\item 'mid.pred': the y position of the predicted midline
}

\code{dim} the x and y dimensions of the images analyzed
}
\description{
A wrapper function for \code{find.roi} that automatically ROIs that are free to move in the spatial field of an image sequence. Does so through thresholding and segmentation. Estimates midlines by various methods. Also outputs the midline amplitude relative to a reference line determined by an anterior section of the ROI. Supported image formats are jpeg, png, and tiff. Supports parallel processing of frames.
}
\details{
By default, the position of the anterior of the ROI (that which is moving forward in the field) is determined by the displacement of the ROI between the first two frames. Thus, \code{frames} must be >1. For analyses of relatively static ROIs in the field (e.g., steadily swimming animals in flumes, etc.), automatically determining the anterior of the ROI may be spurious. In this case, the automatic determination of the anterior should be overridden by specifying 'l', 'r', 'u', 'd' with \code{ant.pos}. These values specify that the anterior region of the ROI is leftmost, rightmost, upmost, or downmost in the field, respectively, and assumes that the origin of the field (0,0) is the upper left corner of each frame. 

Thresholding operations are preformed with \code{link{find.roi}}. Parameters for this function are passed through addition arguments with ...


Midline estimation is pursued by one of three algorithms: bisection of contours across the long axis defined by the tips using \code{\link{free.ml.ang}} or \code{\link{free.ml.hull}}  or by Delaunay triangulation using \code{\link{free.ml.del}}. The default is 'hull' This choice is not arbitrary. The use of \code{free.ml.ang} and \code{free.ml.hull} can be faster, but perfom poorly for tips that snake back on themselves (i.e., a high degree curvature). The use of \code{free.ml.del} can be slowe for high resolution outlines, but  produces better results when contour regions overlap (i.e, those that snake back on themselves), but produces less precise midlines for complicated contours.

For midline smoothing, if \code{ml.smooth} contains 'spline' (the default), \code{\link{smooth_spline}} from the \code{smoothr} package is used to interpolate points between a reduced number of vertices using piecewise cubic polynomials. The number of vertices is calculated based on the number of midline coordinates times numeric value of the list in \code{ml.smooth}. If \code{ml.smooth} contains 'loess', \code{loess} is used to fit a polynomial surface. For contours that have a complicated midline with non-unique x values, loess smoothing can produce poor results. Thus, spline smoothing is usually the advisable option. 

For contour smoothing \code{smooth.n} is passed to the \code{n} parameter of \code{\link{free.ml.ang}}, \code{\link{free.ml.hull}}, or \code{\link{free.ml.del}}, which smooths coordinates using a simple moving average. Users should be wary of oversmoothing by smoothing both the contour (from which the midline is calculated) and the midline.
}
\examples{

##A somewhat long example
#### plot midline waveform on images of swimming ropefish
\dontrun{
#download example video and establish directories
f <- "https://github.com/ckenaley/exampledata/blob/master/ropefish.avi?raw=true"
download.file(f, paste0(tempdir(),"/ropefish.avi"))

dir.create(paste0(tempdir(),"/images"))
dir.create(paste0(tempdir(),"/out"))
#extract images
vid.to.images(paste0(tempdir(),"/ropefish.avi"), out.dir = paste0(tempdir(),"/images"))

#run kin.free() 

kin <- kin.free(image.dir =paste0(tempdir(),"/images"),
      par=TRUE,
      save=TRUE,
      out.dir=paste0(tempdir(),"/out"),
      ml.smooth=list("spline",0.5),
      thr = "otsu",
      ml.meth="ang",
      ant.pos="l",
      red=0.5,
      size.min=0.01
      )


#see results
#images
fi <- list.files(paste0(tempdir(),"/out"),full.names=TRUE)
EBImage::display(EBImage::readImage(fi[320]),"raster")

#with gg.overlay() on first 300 frames

gg.overlay(kin=kin,data="midline",frames=0:300,size=.2,animate=TRUE,zoom=FALSE,alpha=0.01,col="red",fps=10)

#clean up
unlink(paste0(tempdir(),"/images"),recursive=TRUE)
unlink(paste0(tempdir(),"/out"),recursive=TRUE)


}



}
\seealso{
\code{\link{kin.search}}, \code{\link{kin.simple}},\code{\link{free.ml.bis}}, \code{\link{free.ml.del}}
}
